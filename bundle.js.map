{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./javascripts/app.js","webpack:///./javascripts/beam.js","webpack:///./javascripts/game.js","webpack:///./javascripts/laser.js","webpack:///./javascripts/mirror.js","webpack:///./javascripts/sprite.js","webpack:///./javascripts/util.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kDAA0C,gCAAgC;AAC1E;AACA;;AAEA;AACA;AACA;AACA,gEAAwD,kBAAkB;AAC1E;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAyC,iCAAiC;AAC1E,wHAAgH,mBAAmB,EAAE;AACrI;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;;;;AClFA;;AAEA;AACA;AACA;;AAEA;AACA,CAAC;;;;;;;;;;;;;;;;ACFA;;AAED;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB,qBAAqB;AACxC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,MAAM,uBAAuB;AAC7B;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;;;;;;AC1DA;AACA;AACyB;AACE;;AAE3B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA,WAAW,kCAAkC;AAC7C;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,0CAA0C,QAAQ;AAClD;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,mBAAmB,uBAAuB;AAC1C;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,wBAAwB;AAC3C;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,0BAA0B;AAC7C;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,mBAAmB,0BAA0B;AAC7C;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,0BAA0B;AAC7C;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;;;;ACpUA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;;;ACxCA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;;;ACjCA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;;;;;;;;;;;;;;;;;;;AC7DA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./javascripts/app.js\");\n","import Game from './game';\n\ndocument.addEventListener('DOMContentLoaded', () => {\n  const canvas = document.getElementById('canvas');\n  const game = new Game(canvas);\n\n  game.run();\n});\n","import {\n  getRotatedLaserPos,\n  isInBounds,\n  pointIsOnMirrorEdge,\n  collidesWithObject\n} from './util';\n\nfunction getBeamCollision(startPos, angle, entities) {\n  const dx = Math.cos(angle);\n  const dy = Math.sin(angle);\n  const canvas = entities[0].ctx.canvas;\n  let currPos = [startPos[0], startPos[1]];\n  let collision = false;\n\n  const beamData = {\n    endPos: currPos,\n    angle,\n    beamEnd: true\n  };\n\n  while (isInBounds(currPos, canvas) && !collision) {\n    currPos[0] += dx / 5;\n    currPos[1] += dy / 5;\n\n    for (var i = 0; i < entities.length; i++) {\n      const entity = entities[i];\n      \n      if (collidesWithObject(currPos, entity)) {\n        if (entity.mirror) {\n          if (pointIsOnMirrorEdge(currPos, entity)) {\n            beamData.angle = entity.reflectedAngle(angle);\n            beamData.beamEnd = false;\n          }\n        }\n\n        collision = true;\n        break;\n      }\n    }\n  }\n\n  return beamData;\n}\n\nexport const getBeamPositions = (laser, entities) => {\n  let startPos = getRotatedLaserPos(laser.x, laser.y, laser.width, laser.height, laser.rad);\n  let angle = laser.rad;\n  let beamEnd = false;\n  let endPos;\n  const positions = [startPos];\n\n  while (beamEnd === false) {\n    ({endPos, angle, beamEnd} = getBeamCollision(startPos, angle, entities));\n    startPos = endPos;\n    positions.push(startPos);\n  }\n\n  return positions;\n}\n","import Laser from './laser';\nimport Mirror from './mirror';\nimport {getBeamPositions} from './beam';\nimport {collidesWithObject} from './util';\n\nclass Game {\n  constructor(canvas) {\n    this.canvas = canvas;\n    this.ctx = canvas.getContext(\"2d\");\n\n    this.entities = [];\n    this.currentEntity;\n    this.addEntityProperties = {\n      type: \"laser\",\n      color: \"red\",\n      width: 50,\n      height: 10,\n      deg: 0\n    }\n\n    this.mouseX;\n    this.mouseY;\n    this.dragging = false;\n    this.dragX;\n    this.dragY;\n\n    this.blackout = false;\n  }\n\n  // STARTUP METHODS\n  run() {\n    this.addListeners();\n\n    this.addLaser(430, 300, 140, \"red\");\n    this.addLaser(585, 347, 225, \"lawngreen\");\n    this.addLaser(528, 460, 255, \"blue\");\n    this.addMirror(210, 500, 70, 10, 180);\n    this.addMirror(375, 155, 50, 10, 300);\n    this.addMirror(92, 397, 30, 10, 270);\n    this.addMirror(498, 180, 120, 10, 135);\n    this.addMirror(435, 71, 100, 10, 0);\n\n    this.currentEntity = this.entities[0];\n    this.currentEntity.current = true;\n    this.resizeCanvas();\n\n    window.entities = this.entities;\n  }\n\n  addLaser(x, y, deg, color = \"red\") {\n    this.entities.push(new Laser(this.ctx, x, y, 50, 10, deg, color));\n  }\n\n  addMirror(x, y, width, height, deg) {\n    this.entities.push(new Mirror(this.ctx, x, y, width, height, deg));\n  }\n\n  // EVENT LISTENER METHODS\n  addListeners() {\n    this.startDrag = this.startDrag.bind(this);\n    this.dragEntity = this.dragEntity.bind(this);\n    this.endDrag = this.endDrag.bind(this);\n    this.resizeCanvas = this.resizeCanvas.bind(this);\n    this.controls = this.controls.bind(this);\n    this.windowOnClick = this.windowOnClick.bind(this);\n    this.addEntity = this.addEntity.bind(this);\n    this.updateColor = this.updateColor.bind(this);\n    this.toggleEntity = this.toggleEntity.bind(this);\n\n    window.addEventListener(\"resize\", this.resizeCanvas);\n    document.addEventListener(\"keydown\", this.controls);\n    document.addEventListener(\"mousedown\", this.startDrag);\n\n    document.querySelector(\".open-modal\").addEventListener(\"click\", this.toggleModal);\n    document.querySelector(\".close-button\").addEventListener(\"click\", this.toggleModal);\n    window.addEventListener(\"click\", this.windowOnClick);\n\n    document.querySelectorAll(\"img\").forEach(img => img.addEventListener(\"click\", this.toggleEntity))\n\n    document.getElementById(\"add-entity\").addEventListener(\"click\", this.addEntity);\n\n    document.getElementById(\"red\").addEventListener(\"click\", this.updateColor);\n    document.getElementById(\"yellow\").addEventListener(\"click\", this.updateColor);\n    document.getElementById(\"lawngreen\").addEventListener(\"click\", this.updateColor);\n    document.getElementById(\"blue\").addEventListener(\"click\", this.updateColor);\n\n    document.querySelector(\"input\").addEventListener(\"change\", e => {\n      this.addEntityProperties.width = parseInt(e.target.value);\n    });\n\n    document.getElementById(\"light-toggle\").addEventListener(\"click\", () => {\n      this.blackout = !this.blackout;\n      this.drawGame();\n    });\n  }\n\n  toggleEntity(e) {\n    document.querySelectorAll(\"img\").forEach(img => img.classList.toggle(\"active\"));\n    this.addEntityProperties.type = this.addEntityProperties.type === \"laser\" ? \"mirror\" : \"laser\";\n  }\n\n  addEntity(e) {\n    const { type, color, width, height, deg } = this.addEntityProperties;\n    e.stopPropagation();\n\n    if (type === \"laser\") {\n      this.addLaser(57.5 - width / 2, 322.5 - height / 2, deg, color);\n    } else {\n      this.addMirror(57.5 - width / 2, 322.5 - height / 2, width, height, deg);\n    }\n    \n    this.drawGame();\n  }\n\n  updateColor(e) {\n    document.getElementById(this.addEntityProperties.color).classList.remove(\"selected-color\");\n    this.addEntityProperties.color = e.target.id;\n    e.target.classList.add(\"selected-color\");\n  }\n\n  controls(e) {\n    switch (e.code) {\n      case \"ArrowLeft\":\n      case \"KeyA\":\n        this.currentEntity.rotateSprite(\"counterclockwise\");\n        this.drawGame();\n        break;\n      case \"ArrowRight\":\n      case \"KeyD\":\n        this.currentEntity.rotateSprite(\"clockwise\");\n        this.drawGame();\n        break;\n      default:\n    }\n  }\n\n  startDrag(e) {\n    e.stopPropagation();\n    this.setCursorPosition(e);\n\n    for (var i = this.entities.length - 1; i >= 0; i--) {\n      const entity = this.entities[i];\n\n      if (collidesWithObject([this.mouseX, this.mouseY], entity)) {\n        this.currentEntity.current = false;\n        this.currentEntity = entity;\n        this.currentEntity.current = true;\n        this.entities.splice(i, 1);\n        this.entities.push(entity);\n\n        this.dragging = true;\n        this.dragX = this.mouseX - entity.x;\n        this.dragY = this.mouseY - entity.y;\n        break;\n      }\n    }\n\n    if (this.dragging) {\n      document.querySelector(\"body\").style.setProperty(\"cursor\", \"move\");\n      document.addEventListener(\"mousemove\", this.dragEntity, false);\n    }\n\n    document.removeEventListener(\"mousedown\", this.startDrag, false);\n    document.addEventListener(\"mouseup\", this.endDrag, false);\n  }\n\n  dragEntity(e) {\n    this.setCursorPosition(e);\n    const posX = this.mouseX - this.dragX;\n    const posY = this.mouseY - this.dragY;\n    const minX = 0 - this.dragX;\n    const minY = 0 - this.dragY;\n    const maxX = window.innerWidth - this.dragX;\n    const maxY = window.innerHeight - this.dragY;\n\n    this.currentEntity.x = posX < minX ? minX : posX > maxX ? maxX : posX;\n    this.currentEntity.y = posY < minY ? minY : posY > maxY ? maxY : posY;\n\n    this.drawGame();\n  }\n\n  endDrag(e) {\n    document.addEventListener(\"mousedown\", this.startDrag, false);\n    document.removeEventListener(\"mouseup\", this.endDrag, false);\n    e.stopPropagation();\n\n    if (this.dragging) {\n      document.querySelector(\"body\").style.removeProperty(\"cursor\");\n      this.dragging = false;\n      document.removeEventListener(\"mousemove\", this.dragEntity, false);\n\n      if (e.target === document.getElementById(\"remove-entity\")) {\n        this.entities.pop();\n      }\n    }\n    \n    this.drawGame();\n  }\n\n  resizeCanvas() {\n    this.scaleByDevicePixelRatio(window.innerWidth, window.innerHeight);\n    this.drawGame();\n  }\n\n  scaleByDevicePixelRatio(canvasSizeX, canvasSizeY) {\n    this.canvas.style.width = canvasSizeX + \"px\";\n    this.canvas.style.height = canvasSizeY + \"px\";\n\n    const scale = window.devicePixelRatio;\n    this.canvas.width = canvasSizeX * scale;\n    this.canvas.height = canvasSizeY * scale;\n\n    this.ctx.scale(scale, scale);\n  }\n\n  setCursorPosition(e) {\n    const bounds = this.canvas.getBoundingClientRect();\n    this.mouseX = e.clientX - bounds.left;\n    this.mouseY = e.clientY - bounds.top;\n  }\n\n  toggleModal() {\n    document.querySelector(\".modal\").classList.toggle(\"show-modal\");\n  }\n\n  windowOnClick(e) {\n    if (e.target === document.querySelector(\".modal\")) {\n      this.toggleModal();\n    }\n  }\n\n  // RENDER METHODS\n  drawGame() {\n    if (this.blackout) {\n      this.ctx.fillStyle = \"#000\"\n      this.ctx.rect(0, 0, window.innerWidth, window.innerHeight);\n      this.ctx.fill();\n\n      this.renderBeams();\n      this.renderEntities();\n      this.ctx.shadowBlur = 0;\n    } else {\n      this.ctx.fillStyle = \"#EEE\";\n      this.ctx.rect(0, 0, window.innerWidth, window.innerHeight);\n      this.ctx.fill();\n  \n      this.drawBackground();\n      this.renderBeams();\n      this.renderEntities();\n    }\n  }\n\n  drawBackground() {\n    this.ctx.strokeStyle = \"#AAA\";\n    this.ctx.lineWidth = 2;\n    this.ctx.globalAlpha = 0.2;\n\n    for (var i = 0; i < window.innerWidth; i += 30) {\n      this.ctx.beginPath();\n      this.ctx.moveTo(i, 0);\n      this.ctx.lineTo(i, this.canvas.height);\n      this.ctx.stroke();\n    }\n\n    for (var i = 0; i < window.innerHeight; i += 30) {\n      this.ctx.beginPath();\n      this.ctx.moveTo(0, i);\n      this.ctx.lineTo(this.canvas.width, i);\n      this.ctx.stroke();\n    }\n\n    this.ctx.globalAlpha = 1;\n\n    var x = window.innerWidth / 2;\n    var y = 5 * window.innerHeight / 6;\n    \n    this.ctx.font = '60px Verdana';\n    this.ctx.fillStyle = '#BBB';\n    this.ctx.textAlign = 'center';\n    this.ctx.textBaseline = 'middle';\n    this.ctx.fillText('LaserLights', x, y);\n  }\n\n  renderBeams() {\n    for (var i = 0; i < this.entities.length; i++) {\n      const entity = this.entities[i];\n\n      if (entity.laser) {\n        const positions = getBeamPositions(entity, this.entities);\n        this.drawBeams(positions, entity.color);\n      }\n    }\n  }\n\n  drawBeams(positions, color) {\n    const ctx = this.ctx;\n\n    ctx.beginPath();\n\n    for (let i = 0; i < positions.length - 1; i++) {\n      ctx.moveTo(positions[i][0], positions[i][1]);\n      ctx.lineTo(positions[i + 1][0], positions[i + 1][1]);\n    }\n\n    ctx.strokeStyle = color;\n    ctx.lineWidth = 2;\n    ctx.stroke();\n  }\n\n  renderEntities() {\n    for (var i = 0; i < this.entities.length; i++) {\n      const entity = this.entities[i];\n      \n      if (this.blackout) {\n        if (entity.laser) {\n          entity.renderBlackout();\n        }\n      } else {\n        entity.render();\n      }\n    }\n  }\n}\n\nexport default Game;\n","import Sprite from './sprite';\nimport * as Util from './util';\n\nclass Laser extends Sprite {\n  constructor(ctx, x, y, width, height, deg, color = \"#F00\") {\n    super(ctx, x, y, width, height, deg, color);\n    this.laserPos = Util.getRotatedLaserPos(\n      this.x,\n      this.y,\n      this.width,\n      this.height,\n      this.rad\n    );\n    this.laser = true;\n  }\n\n  drawLaser(x, y, width, height, ctx, color) {\n    ctx.fillStyle = \"#FFF\";\n    ctx.fillRect(x, y, width - 10, height);\n    ctx.strokeRect(x, y, width - 10, height);\n    ctx.fillStyle = color;\n    ctx.fillRect(x + width - 10, y, 10, height);\n    ctx.strokeRect(x + width - 10, y, 10, height);\n  }\n\n  drawLaserPoint(x, y, width, height, ctx, color) {\n    ctx.fillStyle = color;\n    ctx.fillRect(x + width - 10, y, 10, height);\n    ctx.strokeRect(x + width - 10, y, 10, height);\n  }\n\n  renderBlackout() {\n    super.draw(this.drawLaserPoint, true);\n  }\n\n  render() {\n    super.draw(this.drawLaser);\n  }\n}\n\nexport default Laser;\n","import Sprite from './sprite';\n\nclass Mirror extends Sprite {\n  constructor(ctx, x, y, width, height, deg) {\n    super(ctx, x, y, width, height, deg);\n    this.mirror = true;\n  }\n\n  corners() {\n    return [\n      [this.x, this.y + this.height],\n      [this.x + this.width, this.y + this.height]\n    ];\n  }\n\n  reflectedAngle(angle) {\n    return 2 * this.rad - angle;\n  }\n\n  drawMirror(x, y, width, height, ctx) {\n    ctx.fillStyle = \"#FFF\";\n    ctx.fillRect(x, y, width, height - 4);\n    ctx.strokeRect(x, y, width, height - 4);\n    ctx.fillStyle = \"#BBB\";\n    ctx.fillRect(x, y + height - 4, width, 4);\n    ctx.strokeRect(x, y + height - 4, width, 4);\n  }\n\n  render() {\n    super.draw(this.drawMirror);\n  }\n}\n\nexport default Mirror;\n","import Laser from './laser';\n\nclass Sprite {\n  constructor(ctx, x, y, width, height, deg, color = null) {\n    this.ctx = ctx;\n    this.x = x;\n    this.y = y;\n    this.width = width;\n    this.height = height;\n    this.rad = (deg * Math.PI) / 180;\n    this.color = color;\n    this.current = false;\n  }\n\n  getCenterPos() {\n    return [this.x + this.width / 2, this.y + this.height / 2];\n  }\n\n  draw(drawShape, blackout = false) {\n    this.ctx.strokeStyle = \"#000\";\n    this.ctx.lineWidth = 1;\n\n    this.ctx.translate(this.x + this.width / 2, this.y + this.height / 2);\n    this.ctx.rotate(this.rad);\n\n    drawShape(\n      -this.width / 2,\n      -this.height / 2,\n      this.width,\n      this.height,\n      this.ctx,\n      this.color\n    );\n\n    if (this.current && !blackout) {\n      this.ctx.strokeStyle = \"#C0C\";\n\n      if (this.mirror) {\n        this.ctx.strokeRect(-this.width / 2, -this.height / 2, this.width, this.height - 4);\n      } else {\n        this.ctx.strokeRect(-this.width / 2, -this.height / 2, this.width - 10, this.height);\n      }\n    }\n\n    this.ctx.rotate(2 * Math.PI - this.rad);\n    this.ctx.translate(-this.x - this.width / 2, -this.y - this.height / 2);\n  }\n\n  rotateSprite(dir) {\n    const mult = dir === \"clockwise\" ? 1 : -1;\n\n    if (this.laser) {\n      this.rad += (mult * 0.5 * Math.PI) / 180;\n    } else {\n      this.rad += (mult * 1 * Math.PI) / 180;\n    }\n\n    this.rad = this.rad % (2 * Math.PI);\n  }\n}\n\nexport default Sprite;\n","export const getRotatedLaserPos = (x, y, width, height, rad) => {\n  const theta = rad / 2;\n  const h = width * Math.sin(theta);\n\n  const dx = h * Math.sin(theta);\n  const dy = h * Math.cos(theta);\n\n  return [x + width - dx, y + height / 2 + dy];\n}\n\nexport const getRotatedPos = (pos, centerPos, rad) => {\n  const cx = centerPos[0];\n  const cy = centerPos[1];\n  let px = pos[0];\n  let py = pos[1];\n  const sin = Math.sin(rad);\n  const cos = Math.cos(rad);\n\n  px -= cx;\n  py -= cy;\n\n  const rx = px * cos - py * sin;\n  const ry = px * sin + py * cos;\n\n  return [rx + cx, ry + cy];\n}\n\nexport const isInBounds = (pos, canvas) => {\n  const width = canvas.width;\n  const height = canvas.height;\n\n  return (pos[0] > 0 && pos[0] < width && pos[1] > 0 && pos[1] < height);\n}\n\n\nexport const pointIsOnMirrorEdge = (pos, mirror) => {\n  const x0 = getRotatedPos(pos, mirror.getCenterPos(), -mirror.rad)[0];\n  const y0 = getRotatedPos(pos, mirror.getCenterPos(), -mirror.rad)[1];\n  const corners = mirror.corners();\n  const x1 = corners[0][0];\n  const y1 = corners[0][1];\n  const x2 = corners[1][0];\n  const y2 = corners[1][1];\n\n  const dist = Math.abs((y2 - y1)*x0 - (x2 - x1)*y0 + x2*y1 - y2*x1) / mirror.width;\n\n  return (dist <=  .5);\n}\n\nexport const collidesWithObject = (pos, object) => {\n  const rotatedPos = getRotatedPos(pos, object.getCenterPos(), -object.rad);\n\n  return (\n    rotatedPos[0] >= object.x && rotatedPos[0] <= object.x + object.width &&\n    rotatedPos[1] >= object.y && rotatedPos[1] <= object.y + object.height\n  );\n}\n"],"sourceRoot":""}