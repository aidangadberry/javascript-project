{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./javascripts/app.js","webpack:///./javascripts/beam.js","webpack:///./javascripts/game.js","webpack:///./javascripts/laser.js","webpack:///./javascripts/mirror.js","webpack:///./javascripts/sprite.js","webpack:///./javascripts/util.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kDAA0C,gCAAgC;AAC1E;AACA;;AAEA;AACA;AACA;AACA,gEAAwD,kBAAkB;AAC1E;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAyC,iCAAiC;AAC1E,wHAAgH,mBAAmB,EAAE;AACrI;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;;;;AClFA;;AAEA;AACA;AACA;;AAEA;AACA,CAAC;;;;;;;;;;;;;;;;ACFA;;AAED;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB,oBAAoB;AACvC;AACA;AACA,mBAAmB,yEAAyE;AAC5F,SAAS;AACT,mBAAmB,6CAA6C;AAChE;AACA;AACA;AACA,mBAAmB,mBAAmB;AACtC;AACA,iBAAiB,6CAA6C;AAC9D;AACA;AACA;;AAEA,WAAW,6CAA6C;AACxD;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM,uBAAuB;AAC7B;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AChEA;AACA;AACiB;AAC+B;;AAEhD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,mBAAmB,wBAAwB;AAC3C;AACA;AACA;;AAEA,mBAAmB,yBAAyB;AAC5C;AACA;;AAEA,mBAAmB,wBAAwB;AAC3C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,mBAAmB,wBAAwB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,yBAAyB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;;;;ACtIA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;;;ACVA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;;;ACjBA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;;;;;;;AC9CA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./javascripts/app.js\");\n","import Game from './game';\n\ndocument.addEventListener('DOMContentLoaded', () => {\n  const canvas = document.getElementById('canvas');\n  const game = new Game(canvas);\n\n  game.run();\n});\n","import {\n  getRotatedLaserPos,\n  isInBounds,\n  pointIsOnMirrorEdge,\n  collidesWithObject\n} from './util';\n\nfunction drawBeam(startPos, endPos) {\n  const ctx = document.getElementById('canvas').getContext('2d');\n\n  ctx.beginPath();\n  ctx.moveTo(startPos[0], startPos[1]);\n  ctx.lineTo(endPos[0], endPos[1]);\n\n\n  ctx.strokeStyle = \"#F00\";\n  ctx.shadowBlur = 15;\n  ctx.shadowColor = \"#F00\"\n  \n  ctx.lineWidth = 1;\n  ctx.stroke();\n}\n\n\nfunction getCollision(startPos, angle, lasers, mirrors) {\n  let currPos = startPos.slice(0);\n  const dx = Math.cos(angle);\n  const dy = Math.sin(angle);\n\n  while (isInBounds(currPos)) {\n    currPos[0] += dx / 10;\n    currPos[1] += dy / 10;\n\n    for (var i = 0; i < mirrors.length; i++) {\n      if (collidesWithObject(currPos, mirrors[i])) {\n        if (pointIsOnMirrorEdge(currPos, mirrors[i])) {\n          return ({endPos: currPos, angle: mirrors[i].reflectedAngle(angle), beamEnd: false});\n        } else {\n          return ({endPos: currPos, angle: angle, beamEnd: true});\n        }\n      }\n    }\n    for (var i = 0; i < lasers.length; i++) {\n      if (collidesWithObject(currPos, lasers[i])) {\n        return ({endPos: currPos, angle: angle, beamEnd: true});\n      }\n    }\n  }\n\n  return ({endPos: currPos, angle: angle, beamEnd: true});\n}\n\nexport const getBeams = (laser, lasers, mirrors) => {\n  let laserPos = getRotatedLaserPos(laser.x, laser.y, laser.width, laser.height, laser.rad);\n  let angle = laser.rad;\n  let beamEnd = false;\n  let endPos;\n\n  let startPos = laserPos.slice(0);\n  while (beamEnd === false) {\n    ({endPos, angle, beamEnd} = getCollision(startPos, angle, lasers, mirrors));\n    drawBeam(startPos, endPos);\n    startPos = endPos.slice(0);\n  }\n}\n","import Laser from './laser';\nimport Mirror from './mirror';\nimport {getBeams} from './beam';\nimport {pointIsOnMirrorEdge, collidesWithObject} from './util';\n\nclass Game {\n  constructor(canvas) {\n    this.lasers = [];\n    this.mirrors = [];\n    this.canvas = canvas;\n    this.ctx = canvas.getContext('2d');\n    this.currentSprite;\n\n    this.addListeners();\n  }\n\n  scaleByDevicePixelRatio(canvasSizeX, canvasSizeY) {\n    this.canvas.style.width = canvasSizeX + \"px\";\n    this.canvas.style.height = canvasSizeY + \"px\";\n\n    const scale = window.devicePixelRatio;\n    this.canvas.width = canvasSizeX * scale;\n    this.canvas.height = canvasSizeY * scale;\n\n    this.ctx.scale(scale, scale);\n  }\n\n  resizeCanvas() {\n    this.scaleByDevicePixelRatio(window.innerWidth, window.innerHeight)\n\n    this.renderEntities();\n  }\n\n  run() {\n    this.addLaser(200, 200, 312);\n    this.addLaser(430, 300, 140);\n    this.addMirror(300, 100);\n    this.addMirror(310, 130, 180);\n    this.addMirror(100, 400, 270);\n    this.addMirror(400, 40);\n    this.addMirror(210, 500, 180);\n    this.resizeCanvas();\n    this.currentSprite = this.lasers[1];\n  }\n\n  renderEntities() {\n    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n    \n    for (var i = 0; i < this.lasers.length; i++) {\n      let laser = this.lasers[i]\n      getBeams(laser, this.lasers, this.mirrors);\n    }\n\n    for (var i = 0; i < this.mirrors.length; i++) {\n      this.mirrors[i].draw();\n    }\n\n    for (var i = 0; i < this.lasers.length; i++) {\n      this.lasers[i].draw();\n    }\n  }\n\n  addLaser(x, y, deg = 0) {\n    const laser = new Laser(x, y, this.ctx, deg);\n\n    this.lasers.push(laser);\n  }\n\n  addMirror(x, y, deg = 0) {\n    const mirror = new Mirror(x, y, this.ctx, deg);\n\n    this.mirrors.push(mirror);\n  }\n\n  getCursorPosition(canvas, e) {\n      var bounds = canvas.getBoundingClientRect();\n      var x = e.clientX - bounds.left;\n      var y = e.clientY - bounds.top;\n      return [x, y];\n  }\n\n  addListeners() {\n    let turnInterval = null;\n\n    document.addEventListener(\"keypress\", event => {\n      switch (event.code) {\n        case \"ArrowLeft\":\n        case \"KeyA\":\n          this.currentSprite.rotateSprite(\"counterclockwise\")\n          this.renderEntities();\n          break;\n        case \"ArrowRight\":\n        case \"KeyD\":\n          this.currentSprite.rotateSprite(\"clockwise\");\n          this.renderEntities();\n          break;\n        default:\n      }\n    });\n\n    document.addEventListener(\"keyup\", clearInterval(turnInterval));\n\n    document.addEventListener(\"mousedown\", e => this.onMouseDown(e));\n    window.addEventListener(\"resize\", () => this.resizeCanvas());\n  }\n\n  onMouseDown(e) {\n    e.stopPropagation();\n\n    for (var i = 0; i < this.lasers.length; i++) {\n      if (collidesWithObject(this.getCursorPosition(this.canvas, e), this.lasers[i])) {\n        this.currentSprite = this.lasers[i];\n        Array.from(document.getElementsByTagName('img')).forEach(img => img.classList.remove('active'));\n        document.getElementById('laser-image').classList.add('active');\n        // this.canvas.addEventListener('mousemove', this.onMouseMove);\n        return;\n      }\n    }\n    for (var i = 0; i < this.mirrors.length; i++) {\n      if (collidesWithObject(this.getCursorPosition(this.canvas, e), this.mirrors[i])) {\n        this.currentSprite = this.mirrors[i];\n        Array.from(document.getElementsByTagName('img')).forEach(img => img.classList.remove('active'));\n        document.getElementById('mirror-image').classList.add('active');\n        // this.canvas.addEventListener('mousemove', this.onMouseMove);\n        return;\n      }\n    }\n  }\n\n  // onMouseMove(e) {\n  //   e.stopPropagation();\n  // }\n}\n\nexport default Game;\n","import Sprite from './sprite';\nimport * as Util from './util';\n\nclass Laser extends Sprite {\n  constructor(x, y, ctx, deg) {\n    super(x, y, ctx, deg, \"images/laser_entity.png\");\n    this.laserPos = Util.getRotatedLaserPos(this.x, this.y, this.width, this.height, this.rad);\n  }\n}\n\nexport default Laser;\n","import Sprite from './sprite';\n\nclass Mirror extends Sprite {\n  constructor(x, y, ctx, deg) {\n    super(x, y, ctx, deg, \"images/mirror_entity.png\");\n    this.corners = [[x, y + this.height], [x + this.width, y + this.height]];\n  }\n\n  reflectedAngle(angle) {\n    if (this.rad % (Math.PI) === 0) {\n      return (-angle)\n    } else {\n      return (Math.PI - angle);\n    }\n  }\n}\n\nexport default Mirror;\n","import Laser from './laser';\n\nclass Sprite {\n  constructor(x, y, ctx, deg, url) {\n    this.width = 50;\n    this.height = 20;\n    this.x = x;\n    this.y = y;\n    this.rad = deg * Math.PI / 180;\n    this.ctx = ctx;\n    this.img = new Image();\n    this.img.src = url;\n\n    this.img.onload = () => {\n      this.draw();\n    }\n  }\n\n  getCenterPos() {\n    return [this.x + this.width / 2, this.y + this.height / 2];\n  }\n\n  draw() {\n    this.ctx.shadowBlur = 0;\n    this.ctx.shadowColor = \"transparent\";\n    \n    this.ctx.translate(this.x + this.width / 2, this.y + this.height / 2);\n    this.ctx.rotate(this.rad);\n\n    this.ctx.drawImage(this.img, -this.width / 2, -this.height / 2);\n\n    this.ctx.rotate(2 * Math.PI - this.rad);\n    this.ctx.translate(-this.x - this.width / 2, -this.y - this.height / 2);\n  }\n\n  rotateSprite(dir) {\n    const mult = dir === \"clockwise\" ? 1 : -1;\n\n    if (this instanceof Laser) {\n      this.rad += mult * 0.5 * Math.PI / 180;\n    } else {\n      this.rad += mult * 90 * Math.PI / 180;\n    }\n  }\n}\n\nexport default Sprite;\n","export const getRotatedLaserPos = (x, y, width, height, rad) => {\n  const theta = rad / 2;\n  const h = width * Math.sin(theta);\n\n  const dx = h * Math.sin(theta);\n  const dy = h * Math.cos(theta);\n\n  return [x + width - dx, y + height / 2 + dy];\n}\n\nexport const getRotatedPos = (pos, centerPos, rad) => {\n  const cx = centerPos[0];\n  const cy = centerPos[1];\n  let px = pos[0];\n  let py = pos[1];\n\n  px -= cx;\n  py -= cy;\n\n  const rx = px * Math.cos(rad) - py * Math.sin(rad);\n  const ry = px * Math.sin(rad) + py * Math.cos(rad);\n\n  return [rx + cx, ry + cy];\n}\n\nexport const isInBounds = pos => {\n  const canvas = document.getElementById('canvas');\n  const width = parseInt(canvas.style.width.slice(0, -2));\n  const height = parseInt(canvas.style.height.slice(0, -2));\n\n  return (pos[0] > 0 && pos[0] < width && pos[1] > 0 && pos[1] < height);\n}\n\n\nexport const pointIsOnMirrorEdge = (pos, mirror) => {\n  const x0 = getRotatedPos(pos, mirror.getCenterPos(), -mirror.rad)[0];\n  const y0 = getRotatedPos(pos, mirror.getCenterPos(), -mirror.rad)[1];\n  const x1 = mirror.corners[0][0];\n  const y1 = mirror.corners[0][1];\n  const x2 = mirror.corners[1][0];\n  const y2 = mirror.corners[1][1];\n\n  const dist = Math.abs((y2 - y1)*x0 - (x2 - x1)*y0 + x2*y1 - y2*x1) / mirror.width;\n\n  return (dist <=  .2);\n}\n\nexport const collidesWithObject = (pos, object) => {\n  const rotatedPos = getRotatedPos(pos, object.getCenterPos(), -object.rad);\n\n  return (\n    rotatedPos[0] >= object.x && rotatedPos[0] <= object.x + object.width &&\n    rotatedPos[1] >= object.y && rotatedPos[1] <= object.y + object.height\n  );\n}\n"],"sourceRoot":""}